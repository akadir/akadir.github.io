{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020/06/01-java-generics/","result":{"data":{"site":{"siteMetadata":{"title":"akadir's blog"}},"markdownRemark":{"id":"341a498c-dd5a-5529-b304-b626dc039643","excerpt":"Generic Terms: Term Example Parameterized type List <String> Actual type parameter String Generic type List<E> Formal type parameter E Unbounded wildcard type…","html":"<h3>Generic Terms:</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Parameterized type</td>\n<td>List &#x3C;String></td>\n</tr>\n<tr>\n<td>Actual type parameter</td>\n<td>String</td>\n</tr>\n<tr>\n<td>Generic type</td>\n<td>List&#x3C;E></td>\n</tr>\n<tr>\n<td>Formal type parameter</td>\n<td>E</td>\n</tr>\n<tr>\n<td>Unbounded wildcard type</td>\n<td>List&#x3C;?></td>\n</tr>\n<tr>\n<td>Raw type</td>\n<td>List</td>\n</tr>\n<tr>\n<td>Bounded type parameter</td>\n<td>&#x3C;E extends Number></td>\n</tr>\n<tr>\n<td>Recursive type bound</td>\n<td>&#x3C;T extends Comparable&#x3C;T>></td>\n</tr>\n<tr>\n<td>Bounded wildcard type</td>\n<td>List&#x3C;? extends Number></td>\n</tr>\n<tr>\n<td>Generic method</td>\n<td>static &#x3C;E> List&#x3C;E> <br> asList(E[] a)</td>\n</tr>\n<tr>\n<td>Type token</td>\n<td>String.class</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<blockquote>\n<blockquote>\n<p><strong>Covariant:</strong> f is covariant if A ≤ B implies that f(A) ≤ f(B) <br><code class=\"language-text\">Arrays are covariant.</code></p>\n</blockquote>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Fails at runtime!\nObject[] objectArray = new Long[1];\nobjectArray[0] = &quot;I don&#39;t fit in&quot;; // Throws ArrayStoreException</code></pre></div>\n<br>\n<blockquote>\n<blockquote>\n<p>f is contravariant if A ≤ B implies that f(B) ≤ f(A)</p>\n</blockquote>\n</blockquote>\n<br>\n<blockquote>\n<blockquote>\n<p><strong>Invariant:</strong> f is invariant if neither of the above holds <br><code class=\"language-text\">Generics, by contrast, are invariant.</code></p>\n</blockquote>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Won&#39;t compile!\nList&lt;Object&gt; ol = new ArrayList&lt;Long&gt;(); // Incompatible types\nol.add(&quot;I don&#39;t fit in&quot;);</code></pre></div>\n<br>\n<hr>\n<p>If method is declared by:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Number[] method(ArrayList&lt;Number&gt; list) { ... }</code></pre></div>\n<p>none of the following expressions will compile:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Integer[] result = method(new ArrayList&lt;Integer&gt;());\nNumber[] result = method(new ArrayList&lt;Integer&gt;());\nObject[] result = method(new ArrayList&lt;Object&gt;());</code></pre></div>\n<p>but</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Number[] result = method(new ArrayList&lt;Number&gt;());\nObject[] result = method(new ArrayList&lt;Number&gt;());</code></pre></div>\n<p>will.</p>\n<hr>\n<blockquote>\n<blockquote>\n<p>arrays are reified [JLS, 4.7]. This means that arrays know and enforce their element type at runtime.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Generics, by contrast, are implemented by erasure [JLS, 4.6]. This means that they enforce their type constraints\nonly at compile time and discard (or erase) their element type information at runtime.\n<br><br>Because of erasure, the only parameterized types that are reifiable are unbounded wildcard types such as List&#x3C;?> and Map&#x3C;?,?></p>\n</blockquote>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Why generic array creation is illegal - won&#39;t compile!\nList&lt;String&gt;[] stringLists = new List&lt;String&gt;[1]; // (1)\nList&lt;Integer&gt; intList = List.of(42); // (2)\nObject[] objects = stringLists; // (3)\nobjects[0] = intList; // (4)\nString s = stringLists[0].get(0); // (5)</code></pre></div>\n<hr>\n<p><i><strong>p.s:</strong> These notes were obtained from the book Effective Java 3rd Edition By Joshua Bloch and this\n<a href=\"https://stackoverflow.com/a/8482091/2183174\" target=\"_blank\">stackoverflow answer.</a>\n</i></p>","frontmatter":{"title":"Generics In Java","date":"June 06, 2020","description":"Short Notes About Generics In Java"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2020/06/01-java-generics/","previous":{"fields":{"slug":"/2020/04/01-git-sparse-checkout/"},"frontmatter":{"title":"git sparse checkout"}},"next":null}}}